% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/afni_3dclusterize.R
\name{afni_3dclusterize}
\alias{afni_3dclusterize}
\title{wrapper class for 3dClusterize}
\description{
wrapper class for 3dClusterize

wrapper class for 3dClusterize
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{sided}}{Whether to clusterize 1-sided ('one'), two-sided ('two'), or bi-sided ('bi')}

\item{\code{NN}}{the cluster definition basis: 1 = faces touch; 2 = edges touch; 3 = corners touch}

\item{\code{clust_nvox}}{The minimum number of voxels required for each cluster}

\item{\code{clust_vol}}{The minimum volume (in microliters) required for each cluster}

\item{\code{lower_thresh}}{For two/bi-sided clusterizing, the lower threshold for the left tail of the distribution}

\item{\code{upper_thresh}}{For two/bi-sided clusterizing, the upper threshold for the right tail of the distribution}

\item{\code{one_thresh}}{For one-sided clusterizing, the threshold for the test statistic distribution}

\item{\code{mask}}{the mask within which 3dClusterize searches for clusters}

\item{\code{pref_map}}{The name/location of the pref_map (aka cluster_map) file containing an integer-valued mask of identified clusters}

\item{\code{pref_dat}}{The name/location of the pref_data (aka cluster_masked_data) file containing the input data masked by the clusters}

\item{\code{clusterize_output_file}}{The name of the text file containing the output of 3dClusterize (i.e., the table of clusters)}

\item{\code{whereami}}{passthrough access to whereami object if that has been setup}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-afni_3dclusterize-new}{\code{afni_3dclusterize$new()}}
\item \href{#method-afni_3dclusterize-run}{\code{afni_3dclusterize$run()}}
\item \href{#method-afni_3dclusterize-get_clust_df}{\code{afni_3dclusterize$get_clust_df()}}
\item \href{#method-afni_3dclusterize-get_cluster_map_nifti}{\code{afni_3dclusterize$get_cluster_map_nifti()}}
\item \href{#method-afni_3dclusterize-get_call}{\code{afni_3dclusterize$get_call()}}
\item \href{#method-afni_3dclusterize-get_outputs}{\code{afni_3dclusterize$get_outputs()}}
\item \href{#method-afni_3dclusterize-get_orient}{\code{afni_3dclusterize$get_orient()}}
\item \href{#method-afni_3dclusterize-add_whereami}{\code{afni_3dclusterize$add_whereami()}}
\item \href{#method-afni_3dclusterize-is_complete}{\code{afni_3dclusterize$is_complete()}}
\item \href{#method-afni_3dclusterize-generate_subclusters}{\code{afni_3dclusterize$generate_subclusters()}}
\item \href{#method-afni_3dclusterize-run_subclustering}{\code{afni_3dclusterize$run_subclustering()}}
\item \href{#method-afni_3dclusterize-has_clusters}{\code{afni_3dclusterize$has_clusters()}}
\item \href{#method-afni_3dclusterize-reset_cache}{\code{afni_3dclusterize$reset_cache()}}
\item \href{#method-afni_3dclusterize-get_subclust_list}{\code{afni_3dclusterize$get_subclust_list()}}
\item \href{#method-afni_3dclusterize-subset_atlas_against_clusters}{\code{afni_3dclusterize$subset_atlas_against_clusters()}}
\item \href{#method-afni_3dclusterize-delete_outputs}{\code{afni_3dclusterize$delete_outputs()}}
\item \href{#method-afni_3dclusterize-clone}{\code{afni_3dclusterize$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-afni_3dclusterize-new"></a>}}
\if{latex}{\out{\hypertarget{method-afni_3dclusterize-new}{}}}
\subsection{Method \code{new()}}{
initialization function for a new afni_3dclusterize object. Arguments largely mirror the 3dClusterize parameters.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{afni_3dclusterize$new(
  inset = NULL,
  mask = NULL,
  threshold_file = NULL,
  data_file = NULL,
  mask_from_hdr = NULL,
  out_mask = NULL,
  ithr = NULL,
  idat = NULL,
  onesided = NULL,
  twosided = NULL,
  bisided = NULL,
  lower_thresh = NULL,
  upper_thresh = NULL,
  one_thresh = NULL,
  one_tail = NULL,
  NN = NULL,
  clust_nvox = NULL,
  clust_vol = NULL,
  pref_map = "default",
  pref_dat = "default",
  quiet = NULL,
  orient = NULL,
  binary = NULL,
  clusterize_output_file = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{inset}}{A 4D dataset containing the statistic to use for thresholding (ithr) and, optionally, the data value to output/retain}

\item{\code{mask}}{If specified, the volume will be masked by \code{mask} prior to clusterizing}

\item{\code{threshold_file}}{A 3D dataset containing the statistic to use for thresholding. Mutually exclusive with \code{inset}
If passed, \code{ithr} and \code{idat} are ignored because the \code{inset} file is generated internally.}

\item{\code{data_file}}{A 3D dataset containing the data value to be retained in clusters post-thresholding.
Must be passed with \code{threshold_file} and will be stitched together with it internally. Mutually exclusive with \code{inset}.}

\item{\code{mask_from_hdr}}{passes through as -mask_from_hdr}

\item{\code{out_mask}}{passes through as -out_mask}

\item{\code{ithr}}{sub-brik number for the voxelwise threshold. Passes through as -ithr}

\item{\code{idat}}{sub-brik number for the voxelwise data to be output in cluster table. Passes through as -idat}

\item{\code{onesided}}{if TRUE, clusterizing will be conducted on one tail of the statistic distribution (-ithr)}

\item{\code{twosided}}{if TRUE, clusterizing will be conducted on both tails of the statistic distribution (-ithr)}

\item{\code{bisided}}{if TRUE, clusterizing will be conducted on each tail of the distribution individually}

\item{\code{lower_thresh}}{the lower tail cutoff for two/bi-sided testing}

\item{\code{upper_thresh}}{the upper tail cutoff for two/bi-sided testing}

\item{\code{one_thresh}}{The threshold value for one-sided testing}

\item{\code{one_tail}}{For one-sided clusterizing, whether to threshold the LEFT or RIGHT tail of the distribution}

\item{\code{NN}}{1, 2, 3. Default: 1. Passes through as -NN.}

\item{\code{clust_nvox}}{The minimum number of voxels allowed in a cluster. Passes through as -clust_nvol}

\item{\code{clust_vol}}{The minimum volume in (microliters) allowed in a cluster (mutually exclusive with clust_nvox). 
Passes through as -clust_vol}

\item{\code{pref_map}}{File name for the integer-valued mask containing each cluster, ordered by descending voxel size.
Passes through as -pref_map.}

\item{\code{pref_dat}}{File name for the clusterized and thresholded data. Passes through as -pref_dat.}

\item{\code{quiet}}{passes through as -quiet.}

\item{\code{orient}}{passes through as -orient. 'RAI' or 'LPI'. Default is LPI.}

\item{\code{binary}}{if TRUE, the pref_map (cluster mask) will be output as a 1/0 binary image instead of integer-valued. 
Passes through as -binary.}

\item{\code{clusterize_output_file}}{The name/location of the 3dClusterize output file containing a table of identified clusters.
Defaults to adding the suffix '_clusters.1D' to the input image and placing the file in the same folder as the input.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-afni_3dclusterize-run"></a>}}
\if{latex}{\out{\hypertarget{method-afni_3dclusterize-run}{}}}
\subsection{Method \code{run()}}{
run the 3dClusterize command relevant to this object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{afni_3dclusterize$run(force = FALSE, quiet = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{force}}{if TRUE, 3dClusterize will be re-run}

\item{\code{quiet}}{if TRUE, don't output messages as object is run or checked}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-afni_3dclusterize-get_clust_df"></a>}}
\if{latex}{\out{\hypertarget{method-afni_3dclusterize-get_clust_df}{}}}
\subsection{Method \code{get_clust_df()}}{
return the 3dClusterize table of clusters as a data.frame
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{afni_3dclusterize$get_clust_df(
  include_whereami = TRUE,
  include_subclusters = TRUE,
  include_overlap = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{include_whereami}}{If TRUE and if $add_whereami() is already complete, merge the whereami data
into the cluster data.frame that is returned by this function.}

\item{\code{include_subclusters}}{If TRUE and if $generate_subclusters() is already complete, merge the subcluster
data into the cluster data.frame that is returned by this function.}

\item{\code{include_overlap}}{If TRUE and if $add_whereami() is already complete, merge the mask overlap data into
the cluster data.frame as a nested list-column called overlap (since there are many rows for each ROI)}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
This function will return an empty data.frame if the 3dClusterize output file cannot be found.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-afni_3dclusterize-get_cluster_map_nifti"></a>}}
\if{latex}{\out{\hypertarget{method-afni_3dclusterize-get_cluster_map_nifti}{}}}
\subsection{Method \code{get_cluster_map_nifti()}}{
method to read and return the integer-valued clusterized mask (aka -pref_map) as an oro.nifti object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{afni_3dclusterize$get_cluster_map_nifti()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
an oro.nifti object containing the clusterized mask from 3dClusterize
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-afni_3dclusterize-get_call"></a>}}
\if{latex}{\out{\hypertarget{method-afni_3dclusterize-get_call}{}}}
\subsection{Method \code{get_call()}}{
returns the 3dClusterize call for this specification
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{afni_3dclusterize$get_call()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-afni_3dclusterize-get_outputs"></a>}}
\if{latex}{\out{\hypertarget{method-afni_3dclusterize-get_outputs}{}}}
\subsection{Method \code{get_outputs()}}{
Provides a vector of expected output files that correspond to this 3dClusterize setup
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{afni_3dclusterize$get_outputs(exclude_missing = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{exclude_missing}}{if TRUE (default), any output file that cannot be found will be returned as NA.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a named vector of output files related to this 3dClusterize setup
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-afni_3dclusterize-get_orient"></a>}}
\if{latex}{\out{\hypertarget{method-afni_3dclusterize-get_orient}{}}}
\subsection{Method \code{get_orient()}}{
returns the orientation code for this 3dClusterize call (LPI or RAI)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{afni_3dclusterize$get_orient()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-afni_3dclusterize-add_whereami"></a>}}
\if{latex}{\out{\hypertarget{method-afni_3dclusterize-add_whereami}{}}}
\subsection{Method \code{add_whereami()}}{
Add's an afni_whereami object to this class in the $whereami slot. The corresponding
  whereami command is also run when this is added so that coordinates and labels can be obtained
  immediately. To access the whereami object and its methods, use $whereami()
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{afni_3dclusterize$add_whereami(atlases = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{atlases}}{An optional character vector of atlases to be requested in whereami.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-afni_3dclusterize-is_complete"></a>}}
\if{latex}{\out{\hypertarget{method-afni_3dclusterize-is_complete}{}}}
\subsection{Method \code{is_complete()}}{
returns TRUE if all expected output files exist for this 3dClusterize call
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{afni_3dclusterize$is_complete()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-afni_3dclusterize-generate_subclusters"></a>}}
\if{latex}{\out{\hypertarget{method-afni_3dclusterize-generate_subclusters}{}}}
\subsection{Method \code{generate_subclusters()}}{
break up large clusters into subclusters
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{afni_3dclusterize$generate_subclusters(
  break_nvox = 400,
  min_subclust_nvox = 25,
  max_subclust_nvox = NULL,
  min_n_subclust = 2,
  max_n_subclust = NULL,
  step_size = 0.1,
  max_iter = 50,
  add_whereami = TRUE,
  whereami_atlases = NULL,
  print_progress = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{break_nvox}}{Break up any clusters larger than this value into subclusters. Default: 400}

\item{\code{min_subclust_nvox}}{The smallest number of voxels allowed in a subcluster. Default: 25.}

\item{\code{max_subclust_nvox}}{The largest numver of voxels allowed in a subcluster. If NULL, no upper limit is set.}

\item{\code{min_n_subclust}}{The smallest number of subclusters that will be allowed. Must be 2 or greater. Default: 2}

\item{\code{max_n_subclust}}{The maximum number of subclusters that will be allowed. If NULL, no upper limit is set.}

\item{\code{step_size}}{The step size used to change the threshold values in the test statistic map being clusterized. Default: 0.1.}

\item{\code{max_iter}}{The maximum number of steps to be taken for subcluster search. Default: 50.}

\item{\code{add_whereami}}{If TRUE, whereami will be run for each subcluster. Default: TRUE}

\item{\code{whereami_atlases}}{Passes through to afni_whereami for specifying which atlases to use in lookup}

\item{\code{print_progress}}{If TRUE, the user will see the thresholds being used to subcluster each region.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-afni_3dclusterize-run_subclustering"></a>}}
\if{latex}{\out{\hypertarget{method-afni_3dclusterize-run_subclustering}{}}}
\subsection{Method \code{run_subclustering()}}{
runs a subclustering algorithm on this object, increasing the thresholds until the desired constraints are satisfied
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{afni_3dclusterize$run_subclustering(
  min_clust = NULL,
  max_clust = NULL,
  min_nvox = NULL,
  max_nvox = NULL,
  step_size = NULL,
  refine_steps = 5,
  max_iter = 50,
  print_progress = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{min_clust}}{The minimum number of clusters that will be accepted}

\item{\code{max_clust}}{The maximum number of clusters that will be accepted}

\item{\code{min_nvox}}{The minimum number of voxels in a subcluster that will be accepted}

\item{\code{max_nvox}}{The maximum number of voxels in a subcluster that will be accepted}

\item{\code{step_size}}{The increments in the threshold values from one step to the next.}

\item{\code{refine_steps}}{The number of steps backward from a winning solution. This maximizes the subcluster sizes. Default: 5.}

\item{\code{max_iter}}{The maximum number of increment steps that will be taken before giving up. Default: 50.}

\item{\code{print_progress}}{If TRUE, the user will see the thresholds being used to subcluster each region.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
this is intended to be used internally
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-afni_3dclusterize-has_clusters"></a>}}
\if{latex}{\out{\hypertarget{method-afni_3dclusterize-has_clusters}{}}}
\subsection{Method \code{has_clusters()}}{
check whether clusteres were found
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{afni_3dclusterize$has_clusters()}\if{html}{\out{</div>}}
}

\subsection{Details}{
returns TRUE if clusters were found, FALSE if they were not found, and NULL if the expected cluster
  output file does not exist (e.g., if 3dClusterize has not been run yet)
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-afni_3dclusterize-reset_cache"></a>}}
\if{latex}{\out{\hypertarget{method-afni_3dclusterize-reset_cache}{}}}
\subsection{Method \code{reset_cache()}}{
not intended to be called by user, this resets the cluster data.frame and whereami objects to NULL
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{afni_3dclusterize$reset_cache()}\if{html}{\out{</div>}}
}

\subsection{Details}{
this is used internally when cloning the parent clusterize object for subclustering
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-afni_3dclusterize-get_subclust_list"></a>}}
\if{latex}{\out{\hypertarget{method-afni_3dclusterize-get_subclust_list}{}}}
\subsection{Method \code{get_subclust_list()}}{
return list of subcluster details for each large ROI broken up by generate_subclusters()
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{afni_3dclusterize$get_subclust_list()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-afni_3dclusterize-subset_atlas_against_clusters"></a>}}
\if{latex}{\out{\hypertarget{method-afni_3dclusterize-subset_atlas_against_clusters}{}}}
\subsection{Method \code{subset_atlas_against_clusters()}}{
Compares the clusters generated by 3dClusterize to an atlas of interest, then returns the subset of the
  atlas that overlaps sufficiently with the map from 3dClusterize
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{afni_3dclusterize$subset_atlas_against_clusters(
  atlas_file = NULL,
  atlas_lower_threshold = 0,
  atlas_upper_threshold = Inf,
  minimum_overlap = 0.8,
  mask_by_overlap = FALSE,
  output_atlas = "default",
  roi_stats = c("mean", "max", "min")
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{atlas_file}}{A NIfTI file containing parcels or perhaps meta-analytic statistics}

\item{\code{atlas_lower_threshold}}{Only retain values greater than this threshold in the comparison against the clusters. Default: 0}

\item{\code{atlas_upper_threshold}}{Only retain values less than this threshold in the comparison against the clusters. 
Default: Inf (retain all high values)}

\item{\code{minimum_overlap}}{The proportion overlap of an atlas parcel with a cluster required for the parcel to be retained.
Default: 0.8}

\item{\code{mask_by_overlap}}{If TRUE, only voxels in the atlas that overlapped with a cluster are retained. In essence,
this erodes the retained atlas parcels to only include voxels that were in a cluster. Default: FALSE}

\item{\code{output_atlas}}{the name/location of the file to output containing the subset of parcels in \code{atlas_file} that
are retained by this function. If \code{'default'} or \code{TRUE}, the subset atlas will be placed in the same
folder as the 3dClusterize input image, with a filename that combines the atlas file name with the input/threshold
image name. To disable creation of this file, set \code{output_atlas = FALSE}.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-afni_3dclusterize-delete_outputs"></a>}}
\if{latex}{\out{\hypertarget{method-afni_3dclusterize-delete_outputs}{}}}
\subsection{Method \code{delete_outputs()}}{
method to delete any/all files generated by this object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{afni_3dclusterize$delete_outputs(prompt = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{prompt}}{if TRUE, user will have to confirm deletion of each file. If FALSE, files are deleted without prompting.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-afni_3dclusterize-clone"></a>}}
\if{latex}{\out{\hypertarget{method-afni_3dclusterize-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{afni_3dclusterize$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
